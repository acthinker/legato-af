<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Legato: Thread Control API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <img alt="Logo" src="legatoLogo.png"/>
    <div id="projectbrief">Simplifying M2M development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('c_threading.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Thread Control API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="le__thread_8h.html">Click here for the API reference documentation.</a></p>
<hr/>
<p><a class="el" href="c_threading.html#threadCreating">Creating a Thread</a> <br/>
 <a class="el" href="c_threading.html#threadTerminating">Terminating a Thread</a> <br/>
 <a class="el" href="c_threading.html#threadJoining">Joining</a> <br/>
 <a class="el" href="c_threading.html#threadLocalData">Thread-Local Data</a> <br/>
 <a class="el" href="c_threading.html#threadSynchronization">Thread Synchronization</a> <br/>
 <a class="el" href="c_threading.html#threadDestructors">Thread Destructors</a> <br/>
</p>
<p>Generally, using single-threaded, event-driven programming (registering callbacks to be called by an event handling loop running in a single thread) is more efficient than using multiple threads. With single-threaded, event driven designs:</p>
<ul>
<li>there's no CPU time spent switching between threads.</li>
<li>there's only one copy of thread-specific memory objects, like the procedure call stack.</li>
<li>there's no need to use thread synchronization mechanisms, like mutexes, to prevent race conditions between threads.</li>
</ul>
<p>Sometimes, this style doesn't fit well with a problem being solved, so you're forced to implement workarounds that severely complicate the software design. In these cases, it is far better to take advantage of multi-threading to simplify the design, even if it means that the program uses more memory or more CPU cycles. In some cases, the workarounds required to avoid multi-threading will cost more memory and/or CPU cycles than using multi-threading would.</p>
<p>But you must <b> be careful </b> with multi-threading. Some of the most tenacious, intermittent defects known to humankind have resulted from the misuse of multi-threading. Ensure you know what you are doing.</p>
<h1><a class="anchor" id="threadCreating"></a>
Creating a Thread</h1>
<p>To create a thread, call <code><a class="el" href="le__thread_8h.html#a87e02a46f92e9e3e11ed28a2b265872f">le_thread_Create()</a></code>.</p>
<p>All threads are <b>named</b> for two reasons:</p>
<ol type="1">
<li>To make it possible to address them by name.</li>
<li>For diagnostics.</li>
</ol>
<p>Threads are created in a suspended state. In this state, attributes like scheduling priority and stack size can use the appropriate "Set" functions. All attributes have default values so it is not necessary to set any attributes (other than the name and main function address, which are passed into <a class="el" href="le__thread_8h.html#a87e02a46f92e9e3e11ed28a2b265872f">le_thread_Create()</a> ). When all attributes have been set, the thread can be started by calling <a class="el" href="le__thread_8h.html#a38df3877ee5ab9fac17b2fc0be46c27e">le_thread_Start()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is assumed that if a thread <em>T1</em> creates another thread <em>T2</em> then <b>only</b> thread <em>T1</em> will set the attributes and start thread <em>T2</em>. No other thread should try to set any attributes of <em>T2</em> or try to start it.</dd></dl>
<h1><a class="anchor" id="threadTerminating"></a>
Terminating a Thread</h1>
<p>Threads can terminate themselves by:</p>
<ul>
<li>returning from their main function</li>
<li>calling <a class="el" href="le__thread_8h.html#a6b8e349107ae6628ed8807588f044faa">le_thread_Exit()</a>.</li>
</ul>
<p>Threads can also tell other threads to terminate by "canceling" them; done through a call to <code><a class="el" href="le__thread_8h.html#a0f1c1b98f354a96e6e31e55a71b58f6a">le_thread_Cancel()</a></code>.</p>
<p>If a thread terminates itself, and it is "joinable", it can pass a <code>void*</code> value to another thread that "joins" with it. See <a class="el" href="c_threading.html#threadJoining">Joining</a> for more information.</p>
<p>Canceling a thread may not cause the thread to terminate immediately. If it is in the middle of doing something that can't be interrupted, it will not terminate until it is finished. See 'man 7 pthreads' for more information on cancellation and cancellation points.</p>
<h1><a class="anchor" id="threadJoining"></a>
Joining</h1>
<p>Sometimes, you want single execution thread split (fork) into separate threads of parallel execution and later join back together into one thread later. Forking is done by creating and starting a thread. Joining is done by a call to <a class="el" href="le__thread_8h.html#adf7f24fec4859ca12a52b16ce43fd9b8">le_thread_Join()</a>. le_thread_Join(T) blocks the calling thread until thread T exits.</p>
<p>For a thread to be joinable, it must have its "joinable" attribute set (using <a class="el" href="le__thread_8h.html#a8959f09f66f365916a6a4fbdaf36cf65">le_thread_SetJoinable()</a>) prior to being started. Normally, when a thread terminates, it disappears. But, a joinable thread doesn't disappear until another thread "joins" with it. This also means that if a thread is joinable, someone must join with it, or its resources will never get cleaned up (until the process terminates).</p>
<p><a class="el" href="le__thread_8h.html#adf7f24fec4859ca12a52b16ce43fd9b8">le_thread_Join()</a> fetches the return/exit value of the thread that it joined with.</p>
<h1><a class="anchor" id="threadLocalData"></a>
Thread-Local Data</h1>
<p>Often, you want data specific to a particular thread. A classic example of is the ANSI C variable <code>errno</code>. If one instance of <code>errno</code> was shared by all the threads in the process, then it would essentially become useless in a multi-threaded program because it would be impossible to ensure another thread hadn't killed <code>errno</code> before its value could be read. As a result, POSIX has mandated that <code>errno</code> be a <em>thread-local</em> variable; each thread has its own unique copy of <code>errno</code>.</p>
<p>If a component needs to make use of other thread-local data, it can do so using the pthread functions pthread_key_create(), pthread_getspecific(), pthread_setspecific(), pthread_key_delete(). See the pthread man pages for more details.</p>
<h1><a class="anchor" id="threadSynchronization"></a>
Thread Synchronization</h1>
<p>Nasty multi-threading defects arise as a result of thread synchronization, or a lack of synchronization. If threads share data, they <b>MUST</b> be synchronized with each other to avoid destroying that data and incorrect thread behaviour.</p>
<dl class="section warning"><dt>Warning</dt><dd>This documentation assumes that the reader is familiar with multi-thread synchronization techniques and mechanisms.</dd></dl>
<p>The Legato C APIs provide the following thread synchronization mechanisms:</p>
<ul>
<li><a class="el" href="c_mutex.html">Mutex API</a></li>
<li><a class="el" href="c_semaphore.html">Semaphore API</a></li>
<li><a class="el" href="c_messaging.html">Low-Level Messaging API</a></li>
</ul>
<h1><a class="anchor" id="threadDestructors"></a>
Thread Destructors</h1>
<p>When a thread dies, some clean-up action is needed (e.g., a connection needs to be closed or some objects need to be released). If a thread doesn't always terminate the same way (e.g., if it might be canceled by another thread or exit in several places due to error detection code), then a clean-up function (destructor) is probably needed.</p>
<p>Legato threads use @ c <a class="el" href="le__thread_8h.html#aa85ee32cc06f219f3c619104f4d97932">le_thread_AddDestructor()</a> for clean-up functions. It registers a function to be called by a specified thread just before it terminates. A parent thread can also call <code><a class="el" href="le__thread_8h.html#a671dbe2927a3b2a13c5150476398f34f">le_thread_AddChildDestructor()</a></code> to register a destructor for a child thread before it starts the child thread.</p>
<p>Multiple destructors can be registered for the same thread. They will be called in reverse order of registration (i.e, the last destructor to be registered will be called first).</p>
<hr/>
<p>Copyright (C) Sierra Wireless, Inc. 2014. All rights reserved. Use of this work is subject to license. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="http://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless 2014
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.6
        </div>
    </div>
</body>
</html>
